<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Therapist - Voice Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        /* Connection Status */
        .connection-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .connection-indicator.connected {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
            border: 1px solid #4CAF50;
        }

        .connection-indicator.disconnected {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid #f44336;
        }

        /* Voice Circle Animations */
        .voice-circle {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.3);
            position: relative;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
        }

        .voice-circle::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            border-radius: 50%;
            border: 2px solid transparent;
            background: linear-gradient(45deg, #00bfff, #ff6b6b) border-box;
            -webkit-mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: exclude;
            mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .voice-circle.listening::before {
            opacity: 1;
            animation: listening-pulse 2s infinite ease-in-out;
        }

        .voice-circle.ai-speaking::before {
            opacity: 1;
            background: linear-gradient(45deg, #ff6b6b, #f7c744) border-box;
            animation: ai-speaking-pulse 1.5s infinite ease-in-out;
        }

        /* Microphone Icon Container */
        .mic-orbit {
            position: relative;
            transition: all 0.3s ease;
        }

        .voice-circle.listening .mic-orbit {
            animation: mic-float 3s infinite ease-in-out;
        }

        .voice-circle.ai-speaking .mic-orbit {
            animation: mic-rotate 2s infinite linear;
        }

        /* Button Styles */
        .control-button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: none;
            border-radius: 25px;
            padding: 12px 24px;
            color: white;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .record-button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            width: 70px;
            height: 70px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.3);
            position: relative;
            overflow: hidden;
        }

        .record-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s;
        }

        .record-button:hover::before {
            transform: translateX(100%);
        }

        .record-button:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
        }

        .record-button.recording {
            background: linear-gradient(45deg, #ff4444, #cc0000);
            animation: record-pulse 1s infinite;
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.6);
        }

        .record-button.processing {
            background: linear-gradient(45deg, #ffab00, #ff6f00);
            animation: processing-spin 2s infinite linear;
        }

        /* Status Text Animations */
        .status-text {
            transition: all 0.3s ease;
        }

        .status-text.listening {
            animation: text-pulse 2s infinite ease-in-out;
        }

        .status-text.ai-speaking {
            color: #ffab00;
            animation: text-glow 1.5s infinite ease-in-out;
        }

        /* Audio Visualizer */
        .audio-visualizer {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 3px;
            height: 30px;
            align-items: flex-end;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .voice-circle.listening .audio-visualizer {
            opacity: 1;
        }

        .visualizer-bar {
            width: 3px;
            background: linear-gradient(to top, #00bfff, rgba(0, 191, 255, 0.3));
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        /* Animations */
        @keyframes listening-pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.05);
                opacity: 1;
            }
        }

        @keyframes ai-speaking-pulse {
            0%, 100% {
                transform: scale(1) rotate(0deg);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.1) rotate(180deg);
                opacity: 1;
            }
        }

        @keyframes mic-float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes mic-rotate {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes record-pulse {
            0%, 100% {
                transform: scale(1.05);
                box-shadow: 0 0 30px rgba(255, 68, 68, 0.6);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 40px rgba(255, 68, 68, 0.8);
            }
        }

        @keyframes processing-spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes text-pulse {
            0%, 100% {
                opacity: 0.8;
            }
            50% {
                opacity: 1;
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            }
        }

        @keyframes text-glow {
            0%, 100% {
                text-shadow: 0 0 10px rgba(255, 171, 0, 0.5);
            }
            50% {
                text-shadow: 0 0 20px rgba(255, 171, 0, 0.8);
            }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .voice-circle {
                width: 150px;
                height: 150px;
            }
            
            .control-button {
                padding: 10px 20px;
                font-size: 14px;
            }
            
            .record-button {
                width: 60px;
                height: 60px;
                font-size: 20px;
            }
            
            .connection-indicator {
                top: 10px;
                right: 10px;
                font-size: 12px;
                padding: 6px 12px;
            }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-between min-h-screen p-4 relative">
    <!-- Connection Status -->
    <div id="connectionStatus" class="connection-indicator disconnected">
        üî¥ Backend: Disconnected
    </div>

    <!-- Header -->
    <header class="w-full flex justify-start">
        <a href="index.html" class="flex items-center text-white hover:text-gray-300 transition-colors duration-200">
            <span class="text-3xl">‚Üê</span>
            <span class="ml-2 text-lg font-semibold">Back to Home</span>
        </a>
    </header>

    <!-- Main Voice Interface -->
    <main class="flex-1 flex flex-col items-center justify-center text-center">
        <!-- Voice Animation Circle -->
        <div class="relative w-64 h-64 flex items-center justify-center mb-8">
            <div id="voiceAnimation" class="voice-circle flex items-center justify-center">
                <div class="w-32 h-32 rounded-full bg-white/20 backdrop-blur-sm flex items-center justify-center">
                    <div class="mic-orbit">
                        <span id="micIcon" class="text-4xl text-white">üé§</span>
                    </div>
                </div>
                <!-- Audio Visualizer -->
                <div class="audio-visualizer">
                    <!-- Bars will be generated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Status Text -->
        <div class="text-white text-xl font-medium mb-8 status-text" id="statusText">
            Ready to listen...
        </div>

        <!-- Controls -->
        <div class="flex gap-4 items-center">
            <button id="switchToTextBtn" class="control-button">
                Switch to Text Chat
            </button>
            <button id="recordBtn" class="record-button">
                üé§
            </button>
        </div>
    </main>

    <!-- Footer -->
    <footer class="w-full max-w-sm text-center">
        <a href="chat.html" class="text-sm font-medium text-white/70 hover:text-white transition-colors duration-200">
            Prefer Text Chat?
        </a>
    </footer>

    <!-- Hidden Audio Element -->
    <audio id="responseAudio" style="display: none;"></audio>

    <script>
        // Backend Configuration
        const BACKEND_CONFIG = {
            BASE_URL: 'http://localhost:8000', // Update to your backend URL
            ENDPOINTS: {
                VOICE_CHAT: '/api/voice-chat',
                HEALTH_CHECK: '/api/health',
                CONVERSATION_HISTORY: '/api/conversation-history'
            }
        };

        // Voice Chat Application Class
        class VoiceTherapyApp {
            constructor() {
                // Audio recording variables
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.isRecording = false;
                this.isPlaying = false;
                this.currentAudio = null;
                this.recordingTimeout = null;
                this.silenceDetectionTimer = null;
                this.isInfiniteLoopActive = false;

                // UI elements
                this.voiceAnimation = document.getElementById('voiceAnimation');
                this.statusText = document.getElementById('statusText');
                this.recordBtn = document.getElementById('recordBtn');
                this.switchToTextBtn = document.getElementById('switchToTextBtn');
                this.responseAudio = document.getElementById('responseAudio');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.micIcon = document.getElementById('micIcon');

                // Audio visualizer
                this.audioContext = null;
                this.analyser = null;
                this.dataArray = null;
                this.visualizerBars = [];

                this.initializeApp();
            }

            async initializeApp() {
                await this.setupAudio();
                this.setupEventListeners();
                this.createAudioVisualizer();
                this.checkBackendConnection();
                
                // Start infinite voice loop immediately
                this.startInfiniteVoiceLoop();
            }

            async setupAudio() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.setupMediaRecorder(stream);
                    this.setupAudioContext(stream);
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    this.updateStatus('Microphone access required. Please allow and refresh.');
                }
            }

            setupMediaRecorder(stream) {
                this.mediaRecorder = new MediaRecorder(stream);
                
                this.mediaRecorder.ondataavailable = (event) => {
                    this.audioChunks.push(event.data);
                };
                
                this.mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(this.audioChunks, { type: 'audio/wav' });
                    this.audioChunks = [];
                    
                    if (audioBlob.size > 1000) { // Only process if there's actual audio data
                        await this.sendAudioToBackend(audioBlob);
                    } else {
                        // If no audio detected, continue the loop
                        if (this.isInfiniteLoopActive) {
                            setTimeout(() => this.startRecording(), 1000);
                        }
                    }
                };
            }

            setupAudioContext(stream) {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    const source = this.audioContext.createMediaStreamSource(stream);
                    
                    source.connect(this.analyser);
                    this.analyser.fftSize = 256;
                    
                    const bufferLength = this.analyser.frequencyBinCount;
                    this.dataArray = new Uint8Array(bufferLength);
                } catch (error) {
                    console.error('Error setting up audio context:', error);
                }
            }

            createAudioVisualizer() {
                const visualizer = this.voiceAnimation.querySelector('.audio-visualizer');
                
                // Create visualizer bars
                for (let i = 0; i < 12; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'visualizer-bar';
                    bar.style.height = '5px';
                    visualizer.appendChild(bar);
                    this.visualizerBars.push(bar);
                }
            }

            updateAudioVisualizer() {
                if (!this.analyser || !this.isRecording) return;
                
                this.analyser.getByteFrequencyData(this.dataArray);
                
                this.visualizerBars.forEach((bar, index) => {
                    const value = this.dataArray[index * 2] || 0;
                    const height = Math.max(3, (value / 255) * 25);
                    bar.style.height = `${height}px`;
                });
                
                if (this.isRecording) {
                    requestAnimationFrame(() => this.updateAudioVisualizer());
                }
            }

            setupEventListeners() {
                // Manual record button (for backup control)
                this.recordBtn.addEventListener('click', () => this.toggleInfiniteLoop());
                this.switchToTextBtn.addEventListener('click', () => this.switchToTextChat());
                
                // Handle spacebar for interruption
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && this.isPlaying) {
                        e.preventDefault();
                        this.interruptAudio();
                    }
                });

                // Handle page visibility changes
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && this.isPlaying) {
                        this.interruptAudio();
                    }
                });

                // Handle page unload
                window.addEventListener('beforeunload', () => {
                    this.stopInfiniteLoop();
                });
            }

            // Infinite Voice Loop Functions
            toggleInfiniteLoop() {
                if (this.isInfiniteLoopActive) {
                    this.stopInfiniteLoop();
                } else {
                    this.startInfiniteVoiceLoop();
                }
            }

            startInfiniteVoiceLoop() {
                this.isInfiniteLoopActive = true;
                this.recordBtn.textContent = '‚èπÔ∏è';
                this.updateStatus('Starting conversation...');
                
                // Start the loop
                this.voiceLoop();
            }

            stopInfiniteLoop() {
                this.isInfiniteLoopActive = false;
                this.recordBtn.textContent = 'üé§';
                
                // Stop any ongoing recording
                if (this.isRecording && this.mediaRecorder.state === 'recording') {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                }
                
                // Stop any ongoing audio playback
                if (this.isPlaying) {
                    this.interruptAudio();
                }
                
                // Clear timers
                if (this.recordingTimeout) {
                    clearTimeout(this.recordingTimeout);
                    this.recordingTimeout = null;
                }
                
                this.updateVoiceAnimation('idle');
                this.updateStatus('Click to start conversation');
            }

            async voiceLoop() {
                while (this.isInfiniteLoopActive) {
                    try {
                        // Step 1: Record user input
                        await this.recordUserInput();
                        
                        if (!this.isInfiniteLoopActive) break;
                        
                        // Small delay between recording and next cycle
                        await this.delay(500);
                        
                    } catch (error) {
                        console.error('Error in voice loop:', error);
                        this.updateStatus('Error in conversation. Retrying...');
                        await this.delay(2000);
                        
                        if (!this.isInfiniteLoopActive) break;
                    }
                }
            }

            async recordUserInput() {
                return new Promise((resolve) => {
                    if (!this.isInfiniteLoopActive || this.isPlaying) {
                        resolve();
                        return;
                    }

                    this.startRecording();
                    
                    // Auto-stop after 8 seconds
                    this.recordingTimeout = setTimeout(() => {
                        if (this.isRecording) {
                            this.stopRecording();
                        }
                        resolve();
                    }, 8000);
                });
            }

            startRecording() {
                if (this.isRecording || this.isPlaying || !this.mediaRecorder) return;

                try {
                    this.mediaRecorder.start();
                    this.isRecording = true;
                    
                    this.updateStatus('Listening... Speak now');
                    this.updateVoiceAnimation('listening');
                    this.updateAudioVisualizer();
                    
                } catch (error) {
                    console.error('Error starting recording:', error);
                    this.updateStatus('Recording error. Please check microphone.');
                }
            }

            stopRecording() {
                if (!this.isRecording || this.mediaRecorder.state !== 'recording') return;

                try {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    
                    if (this.recordingTimeout) {
                        clearTimeout(this.recordingTimeout);
                        this.recordingTimeout = null;
                    }
                    
                    this.updateStatus('Processing...');
                    this.updateVoiceAnimation('processing');
                    
                } catch (error) {
                    console.error('Error stopping recording:', error);
                }
            }

            async sendAudioToBackend(audioBlob) {
                try {
                    this.updateStatus('Sending to AI therapist...');

                    const formData = new FormData();
                    formData.append('audio', audioBlob, 'voice_input.wav');
                    formData.append('session', this.getCurrentSession());
                    
                    const response = await fetch(`${BACKEND_CONFIG.BASE_URL}${BACKEND_CONFIG.ENDPOINTS.VOICE_CHAT}`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const responseData = await response.json();
                    await this.handleBackendResponse(responseData);
                    
                } catch (error) {
                    console.error('Error sending audio to backend:', error);
                    this.updateStatus('Connection error. Continuing...');
                    
                    // Continue the loop even if there's an error
                    if (this.isInfiniteLoopActive) {
                        setTimeout(() => {
                            if (this.isInfiniteLoopActive && !this.isRecording && !this.isPlaying) {
                                this.voiceLoop();
                            }
                        }, 2000);
                    }
                }
            }

            async handleBackendResponse(responseData) {
                try {
                    // Expected response format:
                    // {
                    //   "type": "text" | "voice",
                    //   "content": "text response" | "path/to/audio/file",
                    //   "transcript": "user speech text" (optional)
                    // }

                    if (responseData.type === 'voice' && responseData.content) {
                        await this.playAudioResponse(responseData.content);
                    } else if (responseData.type === 'text' && responseData.content) {
                        await this.playTextResponse(responseData.content);
                    } else {
                        // No response or empty response, continue loop
                        if (this.isInfiniteLoopActive) {
                            setTimeout(() => this.voiceLoop(), 1000);
                        }
                    }

                } catch (error) {
                    console.error('Error handling backend response:', error);
                    this.updateStatus('Error processing response. Continuing...');
                    
                    if (this.isInfiniteLoopActive) {
                        setTimeout(() => this.voiceLoop(), 1000);
                    }
                }
            }

            async playAudioResponse(audioPath) {
                return new Promise((resolve) => {
                    try {
                        this.updateStatus('AI is responding...');
                        this.updateVoiceAnimation('ai-speaking');

                        // Create full audio URL
                        const audioUrl = audioPath.startsWith('http') ? 
                            audioPath : 
                            `${BACKEND_CONFIG.BASE_URL}${audioPath}`;

                        this.responseAudio.src = audioUrl;
                        
                        this.responseAudio.onended = () => {
                            this.isPlaying = false;
                            this.updateVoiceAnimation('idle');
                            this.currentAudio = null;
                            
                            // Continue the infinite loop
                            if (this.isInfiniteLoopActive) {
                                setTimeout(() => this.voiceLoop(), 800);
                            }
                            resolve();
                        };
                        
                        this.responseAudio.onerror = (error) => {
                            console.error('Audio playback error:', error);
                            this.isPlaying = false;
                            this.updateVoiceAnimation('idle');
                            this.currentAudio = null;
                            
                            if (this.isInfiniteLoopActive) {
                                setTimeout(() => this.voiceLoop(), 1000);
                            }
                            resolve();
                        };

                        this.responseAudio.play().then(() => {
                            this.isPlaying = true;
                            this.currentAudio = this.responseAudio;
                        });

                    } catch (error) {
                        console.error('Error playing audio response:', error);
                        this.isPlaying = false;
                        this.updateVoiceAnimation('idle');
                        
                        if (this.isInfiniteLoopActive) {
                            setTimeout(() => this.voiceLoop(), 1000);
                        }
                        resolve();
                    }
                });
            }

            async playTextResponse(textContent) {
                return new Promise((resolve) => {
                    this.updateStatus(`AI: ${textContent}`);
                    this.updateVoiceAnimation('ai-speaking');
                    
                    // Display text response for 3 seconds
                    setTimeout(() => {
                        this.updateVoiceAnimation('idle');
                        
                        if (this.isInfiniteLoopActive) {
                            this.voiceLoop();
                        }
                        resolve();
                    }, Math.max(3000, textContent.length * 50)); // Adjust timing based on text length
                });
            }

            interruptAudio() {
                if (this.currentAudio && this.isPlaying) {
                    this.currentAudio.pause();
                    this.currentAudio.currentTime = 0;
                    this.currentAudio = null;
                    this.isPlaying = false;
                    this.updateVoiceAnimation('idle');
                    
                    // Continue the loop after interruption
                    if (this.isInfiniteLoopActive) {
                        setTimeout(() => this.voiceLoop(), 500);
                    }
                }
            }

            updateVoiceAnimation(state) {
                // Remove all state classes
                this.voiceAnimation.classList.remove('listening', 'ai-speaking', 'processing');
                this.statusText.classList.remove('listening', 'ai-speaking');
                
                // Add current state class
                if (state !== 'idle') {
                    this.voiceAnimation.classList.add(state);
                    this.statusText.classList.add(state);
                }

                // Update button class
                this.recordBtn.classList.remove('recording', 'processing');
                if (state === 'listening') {
                    this.recordBtn.classList.add('recording');
                } else if (state === 'processing') {
                    this.recordBtn.classList.add('processing');
                }
            }

            updateStatus(message) {
                this.statusText.textContent = message;
            }

            async checkBackendConnection() {
                try {
                    const response = await fetch(`${BACKEND_CONFIG.BASE_URL}${BACKEND_CONFIG.ENDPOINTS.HEALTH_CHECK}`);
                    const isConnected = response.ok;
                    this.updateConnectionStatus(isConnected);
                    return isConnected;
                } catch (error) {
                    console.error('Backend connection error:', error);
                    this.updateConnectionStatus(false);
                    return false;
                }
            }

            updateConnectionStatus(isConnected) {
                if (isConnected) {
                    this.connectionStatus.className = 'connection-indicator connected';
                    this.connectionStatus.innerHTML = 'üü¢ Backend: Connected';
                } else {
                    this.connectionStatus.className = 'connection-indicator disconnected';
                    this.connectionStatus.innerHTML = 'üî¥ Backend: Disconnected';
                }
            }

            getCurrentSession() {
                let session = sessionStorage.getItem('therapySession');
                if (!session) {
                    session = 'therapy_session_' + Date.now();
                    sessionStorage.setItem('therapySession', session);
                }
                return session;
            }

            switchToTextChat() {
                this.stopInfiniteLoop();
                window.location.href = 'chat.html';
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            window.voiceApp = new VoiceTherapyApp();
        });

        // Periodic connection check
        setInterval(() => {
            if (window.voiceApp) {
                window.voiceApp.checkBackendConnection();
            }
        }, 30000);
    </script>
</body>
</html>